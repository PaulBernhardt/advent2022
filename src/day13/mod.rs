use std::{
    cmp,
    fmt::{self, Display},
    str::Chars,
};

#[derive(Debug, PartialEq, Eq, Clone)]
enum Packet {
    Packet(Vec<Packet>),
    Int(u32),
}

impl Display for Packet {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Packet::Packet(vec) => {
                let strings: Vec<String> = vec.iter().map(|p| p.to_string()).collect();
                write!(f, "[{}]", strings.join(","))
            }
            Packet::Int(i) => write!(f, "{i}"),
        }
    }
}

impl PartialOrd for Packet {
    fn partial_cmp(&self, other: &Self) -> Option<cmp::Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for Packet {
    fn cmp(&self, other: &Self) -> cmp::Ordering {
        let pair = (self, other);
        match pair {
            (Packet::Packet(first), Packet::Packet(second)) => {
                let first_len = first.len();
                let second_len = second.len();
                let iters = first.iter().zip(second);
                for new_pair in iters {
                    let order = new_pair.0.cmp(new_pair.1);
                    if order != cmp::Ordering::Equal {
                        return order;
                    }
                }
                first_len.cmp(&second_len)
            }
            (Packet::Packet(_), Packet::Int(second)) => {
                pair.0.cmp(&Packet::Packet(vec![Packet::Int(*second)]))
            }
            (Packet::Int(first), Packet::Packet(_)) => {
                Packet::Packet(vec![Packet::Int(*first)]).cmp(pair.1)
            }
            (Packet::Int(first), Packet::Int(second)) => first.cmp(second),
        }
    }
}

type Pair = (Packet, Packet);

fn parse_line(chars: &mut Chars) -> Result<Packet, String> {
    let mut vec = Vec::new();
    while let Some(char) = chars.next() {
        // print!("'{char}' ");
        match char {
            '[' => {
                vec.push(parse_line(chars)?);
            }
            ']' => break,
            ',' => {}
            '\n' => {}
            other => {
                let number = char::to_digit(other, 11)
                    .ok_or_else(|| format!("Could not parse '{other}' as number"))?;
                vec.push(Packet::Int(number))
            }
        }
    }
    Ok(Packet::Packet(vec))
}

fn parse_lines(contents: &str) -> Result<Vec<Pair>, String> {
    let mut pairs: Vec<Pair> = Vec::new();
    for lines in contents.replace("10", "a").split("\n\n") {
        let (one, two) = lines
            .split_once('\n')
            .ok_or_else(|| format!("Invalid pair: {lines}"))?;
        pairs.push((parse_line(&mut one.chars())?, parse_line(&mut two.chars())?));
    }
    Ok(pairs)
}

pub fn solve_a(contents: &str) -> Result<String, String> {
    let mut pairs = parse_lines(contents)?;
    let mut total = 0;
    let mut index = pairs.len();
    while let Some(pair) = pairs.pop() {
        if pair.0.cmp(&pair.1) == cmp::Ordering::Less {
            // println!("Pair {index} is in order");
            total += index;
        }
        index -= 1;
    }
    Ok(format!("{}", total))
}

pub fn solve_b(contents: &str) -> Result<String, String> {
    let mut pairs = parse_lines(contents)?;
    let div1 = parse_line(&mut "[[2]]".chars())?;
    let div2 = parse_line(&mut "[[6]]".chars())?;
    let mut lines = vec![div1, div2];

    while let Some(pair) = pairs.pop() {
        lines.push(pair.0);
        lines.push(pair.1);
    }

    lines.sort();
    let div1 = parse_line(&mut "[[2]]".chars())?;
    let div2 = parse_line(&mut "[[6]]".chars())?;
    let total = (1 + lines.binary_search(&div1).map_err(|_| "Can't find [[2]]")?)
        * (1 + lines.binary_search(&div2).map_err(|_| "Can't find [[6]]")?);
    Ok(format!("{}", total))
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_a() {
        let contents = "\
[1,1,3,1,1]
[1,1,5,1,1]

[[1],[2,3,4]]
[[1],4]

[9]
[[8,7,6]]

[[4,4],4,4]
[[4,4],4,4,4]

[7,7,7,7]
[7,7,7]

[]
[3]

[[[]]]
[[]]

[1,[2,[3,[4,[5,6,7]]]],8,9]
[1,[2,[3,[4,[5,6,0]]]],8,9]";
        let result = solve_a(contents);
        assert_eq!(result.unwrap(), "13");
    }

    #[test]
    fn test_a2() {
        let contents = "\
[[1],[2,3,4]]
[[1],4]";
        let result = solve_a(contents);
        assert_eq!(result.unwrap(), "1");
    }

    #[test]
    fn test_a3() {
        let contents = "\
[7,7,7,7]
[7,7,7]
";
        let result = solve_a(contents);
        assert_eq!(result.unwrap(), "0");
    }

    #[test]
    fn test_a4() {
        let contents = "\
[[[10],7,3,[[6,4,4,1],[],[2,6,7,10]],6],[]]
[[2,[3,5,[8,6,7,1,9],[6]]],[[4,2,10],[],[[8,5,5,9],[7],5],[],9]]

[[[8,6,4],[6,6,[4]],[10,4,5,[0,3,3,6],[2,9,4]],[0,[4,5,9,1,4]]],[8,1]]
[[6,[10,0,9],[[1,3,7,1],[],[],[9,8,2,5]],[2,[3,3,0,0],[10],6,1]],[7,[8,[9,3,8],9],[[9,7,1,2,4],[6,7,9,3,0],4,[7,9,0],10],1],[[1,0,[3,6,7,9,6],[0,3,10,4,6],[8,1,10,2]],[],[3,[3,5,5],[]],[[1,1],7,2]],[[9,[],[]]],[[[0,5,9],[4,3],[10,10,3],2],[1,[0,10]],9]]

[[[],[1,9,6,7,7]],[6,[[4,2],[2],2,[2,3,8,10,1],8]],[[[3,8,1,10],[7,5,2,5,3],3,3,5]],[9]]
[[],[[9],[5,8,[10,3],7,7],6,[2],[]],[1,10,[0],[8],7]]

[[[7,1],[[1,7,8]]],[[3,6,[9]],6,8],[[[5,8,9,10],[5,6,0,4,6]],9]]
[[7,[[8],[3,7,8,1,3]]],[[1,[1,2,3,5,1],1,[9,2,0],[8,8,9,7]],[1,8,[9,0]],[],[],[10,[10,8],4]]]

[[9,[[10,2],7,3,3]]]
[[1,4,[],4,[]],[2,0,[0]],[[[8,9],[6,3,4],[9,7]],[[],[7,8,7,6],9,5],4,0],[],[]]

[[[],[[7,9,4,1]],[],[[2],7,[5,9,5,1],10],8],[[7],[[8]]],[2,10,[],[[4,7],6,6,4]],[2,[7,6],4,[9],[1]],[7,[[2,5,7,6]],[[10,10]],[1,3,9,[0,7,1]]]]
[[0],[]]

[[],[[[],[10,8],[2,7,2,9,10]],3,[4,[0],[8,6,1]],[[9,0,6,3,2],[1],[]],1]]
[[2,[[6,9,8,1,10]],1,10],[[[6,0,2,8,9],[6,7,5,7,3],0]],[[4,8,[3,9,10,5,8],1],10,7],[[[1,7],[7,0,1,4,2],3],1,[[1]],8]]

[[6],[[[],2,[],8,[5,7,1,0,0]],0]]
[[3,6],[0,[],8,[[],0,3,1],5],[[[8,0],[2,3],5],[[6,3,1],2,9,7,1],[7,6,[1,0,2,6],10,5],[5,[0],5],[2,[1,10,4,8],[10,4,1,3,10]]]]

[[8,8,[[5,8,2,4,4]]],[],[2,[[2,4,1],2,5,9,9],[[0,0,8],[1,4,1],0,6,9],[],[]],[10,3,[[0,10,9],[3,5],[2,9,8],[8],1]]]
[[[0,8,2,[0,6,0,3,8]],8,[[0,5,4,0,1],[4,4,5,1,2],6],1,[7,0]],[2,3,7,10],[0,7,6,5,[1,[8],[9,7,4,7,9],5,0]]]

[[[],[9,[1,8,2,0],9,[4]],7,1,[]],[[3,2,7,5],[[0,3]],[10,[4,7,6],[10]],[10,[2,4,0,3,8],[9]],[[3,3],4,[],5,1]],[[1,7,7],0,[1,5],[]]]
[[[],[],[[],[4,1,7,7],2,2,5],1,9],[8,7,10,[[1,9,9,7],2]]]

[[],[[[4,6,1,0],10,10,8]],[[8,[10,8,9,0,8],[1,10,10,7,3]],2,4,3]]
[[[[],7,0],4,[2,[5],[8,2,1,6,9],[0,10],4],[[7],8,[],4,[6,2,10]]],[6,7,[[],1,[8,9,3,9],[9,6,5],[10,0,8,9]],7,[1,4,1]],[]]

[[5,4,[5,[1],[7,7,6,2],[1,8,4],[]],1,[[2,3,5,6,7],[10,4,10]]]]
[[10,[[3,7,6,0],9,9,5],7],[[0,9,[2,3,2],[4,5,0]]],[7],[4,[[5,3,8,0],[10,4,4,4,10],[5]]]]

[[0,[[],3,10,6,[8,8]],[0,[1],8],6],[[5,9,[],0,[5,8,4]],[[],1],[[7,3,7,0,9],[1,7],[5,2,9],[]],[3,[7,8,2,3,2],[3,10],7,10],[3,[2]]],[3],[[2],5,[],[9,[0,0,8,5,0]],[]],[[1,[2],[1,4],4,[2,1,9]],0,2]]
[[],[8]]

[[6,[1,5,[8,6,6,10],3,5],10,6,9],[[7,9,1,[5,3],[1,7,10,3,4]],[[3,3,1,2,0]],[[8],[1],[3,1,6,10,0],3,8],10,[7,[2,2,3]]]]
[[9,[[1,8,2]],3,7],[[[3,7,9,2],[8,10,0,5,7],2,10],[[7,7,7],0],2,10],[],[[],[0]],[10,4,5,[2,7,[5],0],3]]

[[[3,[8,2,2]],3,7],[6,[[10,1],[3]],0,2],[],[0,4,[],2],[2,[9],[4,[5,7,5,7],[0,6,1,9,10]],[[10],[10,3],3,10]]]
[[[[0,8,0,5],[2,0,6,9,9]],[[8,1]],[[],[2,4,3]],0,[0,2,[]]],[9,[1],[]],[[]]]

[[3,[9,9,[9,6,6,2],[]],[3,[5],[4,7,7],[10,5]]],[[5,5],[3],1,10],[]]
[[[[],8,[3]]],[],[],[10,[6,6,[7,8,6],2,7],[8,[1,0,10,4,3]],[[9,0,4],4,[10]],[3,[2,7],[5]]],[9,0,[[0,4,5,2,9],[10,2,8],4,7,7],[0,1,4,[],[4,6,4,3]],[]]]

[[[[],[7,3,7],[1,2,4,3,3],[1,2],[3,10]],4],[[5,[10,3,2,2,8],1,[7,2,3,0,2]],9,[[10]],[]]]
[[[[6,6,5,5,3],[10,7,5],3,[8],0],7],[],[],[],[]]

[[0,0,[0,10,5,[9,5],3],[[5,5,2],[]]],[[[8,10,4,3,3],3,5,[10,5]]]]
[[[8,7,9,8]]]

[[[[],[9,4],[4,5,6,5,4],[2,5],[8]],[2],10,3,[6]],[8,[[6,4,8,3,7],1,[7,1,8,0],6,4],7,9,9],[[[9,4,4],6,[6],[9,8]],4]]
[[4,6,[[6,5,1,9]],8],[[[10],[9,9,4],3,[9,3,4]],[],[[7,9],6,5]]]

[[10,8],[[5,[]]]]
[[[8,10,6,[6,2,0,10]],9,3,[]],[[[9,7,8],1,[],1],4,[[1,8,7,0,4],[],[],[]],0]]

[[[[8,8],[2]],[[3,1,8],[10,1,3],[],10,[7,0]]],[]]
[[[10,[8]],[[8,0,8],3,5,1],[4,[0,3,10,8,9],[0,3],[8,8,5,7,0]],[6],1],[[[7,0],4,[7,6,3,10],4,[8,10,8,9]],[0,9,1],[],0]]

[[]]
[[3,[5,8,[10]]],[7,8,7,[[7],1,2,[4,6],3],[1,[],[]]]]";
        let result = solve_a(contents);
        assert_eq!(result.unwrap(), "147");
    }

    #[test]
    fn test_a5() {
        let contents = "\
[[[10],7,3,[[6,4,4,1],[],[2,6,7,10]],6],[]]
[[2,[3,5,[8,6,7,1,9],[6]]],[[4,2,10],[],[[8,5,5,9],[7],5],[],9]]";
        let result = solve_a(contents);
        assert_eq!(result.unwrap(), "0");
    }
    #[test]
    fn test_a6() {
        let contents = "\
[[[],[1,9,6,7,7]],[6,[[4,2],[2],2,[2,3,8,10,1],8]],[[[3,8,1,10],[7,5,2,5,3],3,3,5]],[9]]
[[],[[9],[5,8,[10,3],7,7],6,[2],[]],[1,10,[0],[8],7]]";
        let result = solve_a(contents);
        assert_eq!(result.unwrap(), "0");
    }
    #[test]
    fn test_a6_b() {
        let contents = "\
[[[],[1,9,6,7,7]],[6,[[4,2],[2],2,[2,3,8,10,1],8]],[[[3,8,1,10],[7,5,2,5,3],3,3,5]],[9]]
[[]]";
        let result = solve_a(contents);
        assert_eq!(result.unwrap(), "0");
    }
    #[test]
    fn test_a7() {
        let contents = "\
[[[],[[7,9,4,1]],[],[[2],7,[5,9,5,1],10],8],[[7],[[8]]],[2,10,[],[[4,7],6,6,4]],[2,[7,6],4,[9],[1]],[7,[[2,5,7,6]],[[10,10]],[1,3,9,[0,7,1]]]]
[[0],[]]

[[],[[[],[10,8],[2,7,2,9,10]],3,[4,[0],[8,6,1]],[[9,0,6,3,2],[1],[]],1]]
[[2,[[6,9,8,1,10]],1,10],[[[6,0,2,8,9],[6,7,5,7,3],0]],[[4,8,[3,9,10,5,8],1],10,7],[[[1,7],[7,0,1,4,2],3],1,[[1]],8]]";
        let result = solve_a(contents);
        assert_eq!(result.unwrap(), "3");
    }

    #[test]
    fn test_a8() {
        let contents = "\
[[],[0],[[[8,10,5,7],[],[6,9]],3,9],[[]]]
[[],[1,[0,8,[],9],3],[[6,1,1,[2,9],4],[],[4,4],[4,[4,2,5,5],[1,0],[6,8,1,4,10],[6,9,5,4]]]]";
        let result = solve_a(contents);
        assert_eq!(result.unwrap(), "1");
    }

    #[test]
    fn test_a9() {
        let contents = "\
[[1],[[],0,[5,[],[5,7,0,2,1],[]]],[[[6,9,6],0,[],[2,4,10],[5,9]],8,3,[[2,3,4],[2,10]],[[10,9,0],[2,9,2,6,8]]],[[[10,4,7,5],7],6]]
[[1],[[],[[],2,3,[6,7,3],10],2,[]],[7],[[[10],5,[3,2,2,10]],[[3,3,0,4,4]],[[8,1,8,7,10],[8,6,9,6,9],2,[0,7,4,9,6],[3,7,0,0,3]],[],8]]";
        let result = solve_a(contents);
        assert_eq!(result.unwrap(), "0");
    }

    #[test]
    fn test_b() {
        let contents = "\
[1,1,3,1,1]
[1,1,5,1,1]

[[1],[2,3,4]]
[[1],4]

[9]
[[8,7,6]]

[[4,4],4,4]
[[4,4],4,4,4]

[7,7,7,7]
[7,7,7]

[]
[3]

[[[]]]
[[]]

[1,[2,[3,[4,[5,6,7]]]],8,9]
[1,[2,[3,[4,[5,6,0]]]],8,9]";
        let result = solve_b(contents);
        assert_eq!(result.unwrap(), "140");
    }
}
